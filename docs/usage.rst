=======
 Usage
=======

Withenv provides the `we` executable. Here is the basic usage.


.. code-block:: bash

   $ we --env foo.yml printenv

The YAML in `foo.yml` gets loaded and applied to the environment. If
the value already exists in the environment, that value will be
overwritten.

You can also use a directory of YAML files.

.. code-block:: bash

   $ we --dir myenv printenv

The files will be applied to the environment in alphabetical order.

You can shorten the flags as well as mixing files and directories.

.. code-block:: bash

   $ we -e foo.yml -d bar -e baz.yml printenv

Each flag will be applied in order from left to right.


YAML Format
===========

You can use a hash or list of hashes in your YAML file. For example:

.. code-block:: yaml

   ---
   FOO: bar
   BAR: hello $FOO

It is not recommended to use a hash in this format because the order
cannot be gauranteed, although, it will probably work just fine. If
you need explicit ordering within your file, use a list of hashes.

.. code-block:: yaml

   ---
   - FOO: bar
   - BAR: hello $FOO

Here we see the `$FOO` variable is used within the value of `$BAR`.


Command Substitutions
=====================

Sometimes you want to replace a variable based on the result of a
command. Say for example, you wanted to grab a value from a `chef
environment <https://docs.chef.io/environments.html>`_. We can use the
`knife <https://docs.chef.io/knife.html>`_ and `jq
<https://stedolan.github.io/jq/>`_ to grab the value and inject into
our environment value.

.. code-block:: yaml

   ---
   - CHEF_ENV: dev
   - TOKEN: "`knife environment show $CHEF_ENV -Fj | jq --raw-output .default_attributes.token`"

The knife command will go to our chef server and grab the
environment's configuration and output it as JSON. This output is
piped to the `jq` command where we are able to use `JSONPath <http://jsonpath.com/>`_ to grab the field value we need. The
`--raw-output` will ensure we don't have any quotes around the value.

We could then use this in a commmand.

.. code-block:: bash

   $ we -e token.yml curl -H 'X-Auth-Token: $TOKEN' http://example.com/api/

Currently, `withenv` supports this dynamic substitution when the value
starts and endswith a backtick.

.. note:: The commands executed are not performed in a shell. Each
          command (or script) is lexically parsed. Any `|` characters
          provide different commands and command is expanded for
          environment variable replacement. Any previously defined
          variables should be available for expansion.


Scripts
=======

Often times there are commands that will output YAML/JSON that you
want to add directly to the environment. Withenv supports a `--script`
flag to run a command and load the result as YAML/JSON in order to add
it to the environment. For example, lets say you stored a SSH key in
`Vault <https://www.vaultproject.io/>`_ and you use an
`AppRole <https://www.vaultproject.io/docs/auth/approle.html>`_ to get a
token.

.. code-block:: yaml

   ---
   - VAULT_APPROLE_ID: 1234
   - VAULT_APPROLE_SECRET: 6789
   - VAULT_TOKEN: "`vault write -format=json auth/approle/login role_id=${VAULT_APPROLE_ID} secret_id=${VAULT_APPROLE_SECRET} | jq -r .auth.client_token`"

With the token available, you can use a `--script` to load the data in the vault:

.. code-block:: bash

   $ we -e vault.yml --script 'vault read -format=json path/to/secrets | jq .data'

With will load the result of the script no matter if it JSON or YAML.


Templates
=========

Some applications don't use environment variables. For these
scenarios, you can use templates to write a config file immediately
before running the program, using data in the environment to fill in
any values.

This is similar to tools such as `confd <http://www.confd.io/>`_ or
`consul-template <https://github.com/hashicorp/consul-template>`_ with
the primary difference being the incoming data is generally from the
environment generated by `we` rather than being limited to data from
the respective service.

For example, here is an `env.yml` with some config data.

.. code-block:: yaml

   ---
   - LISTEN: '10.0.0.1:8900'
   - CLUSTER_HOSTS:
       - 10.0.0.2
       - 10.0.0.3
       - 10.0.0.4

Here is a template that uses the data to write an INI formatted config file.

.. code-block::

   [service]
   listen = {{env "LISTEN"}}
   workers =
   {{- range split " " (env "CLUSTER_HOSTS") }}
      - {{ . }}
   {{- end }}

The template language is the `Go Template Language
<https://golang.org/pkg/text/template/>`_. The functions from the
`sprig library <http://masterminds.github.io/sprig/>`_ are also
available.

In the example, the sprig `env` function is used to get a variable
from the environment. For lists of values, like `CLUSTER_HOSTS`, the
value is available as a list of space delimited strings in the
environment.

With the data and template in place we can try it out.

.. code-block:: bash

   $ we --env env.yml --template my.cfg.tmpl cat my.cfg

By default, the path to the `.tmpl` file is reused and the template is
written to the path with the `.tmpl` removed.

You can also provide an explicit path.

.. code-block:: bash

   $ we --env env.yml --template 'my.cfg.tmpl:/etc/app/my.cfg' cat /etc/app/my.cfg


Creating an Alias
=================

Sometimes you'll find that your environment is composed of a suite of
details. Say for example, you were deploying an application via some
script that uses environment variables to choose what region, cloud
account and process to run.

.. code-block:: bash

   $ we -d envs/apps/foo \
        -e envs/acct/dev.yml \
	-e envs/regions/us-east \
	-E TAG=foo
	./create-app-server

We can create an alias for this by creating an alias YAML file.

.. code-block:: yaml

   # myalias.yml
   ---
   - directory: envs/apps/foo
   - file: envs/acct/dev.yml
   - file: envs/regions/us-east
   - envvar: "TAG=foo"

We can then run our command with a shortened `we` command.

.. code-block:: bash

   $ we -a myalias create-app-server


Loading Defaults
================

Withenv can look for a default alias file called `.withenv.yml`. When
`we` starts, it will look for a config `.withenv.yml` in the current
directory or in your `$HOME` directory. The main `.withenv.yml` can
tell `we` to look for a default alias file to load before any flags
are parsed. Here is a main config example turning on this feature.

.. code-block:: yaml

   ---
   find_config: true


With this in place, `we` will look for a `.withenv.yml` in the current
directory and walk up the filesystem looking for a default alias file.

This is helpful when you want to have an alias file that is loaded
within a hierarchy of folders. For example, if I had a single repo for
multiple projects, paths can be configured once in the root directory
and calls in subdirectories will get the default.

A real world example is Go monorepo where the root directory contains
a `.withenv.yml` that defines the `GOPATH` along with some standard
environment variables. With this in place, a developer can simply run
`we go build` to execute the necessary go commands correctly. This can
also be used reliably for CI jobs to help ensure the same settings are
correct when using automation.


`.envrc` Auto Loading
=====================

When `we` starts, it now also looks for a `.envrc` file in the current
directory and walks upward until one is found. If found, `we` parses
the file for assignment lines (`export KEY=value` and `KEY=value`) and
loads those variables before applying any `we` flags.

Precedence is:

1. Current shell environment
2. `.envrc` values parsed and loaded by `we`
3. Explicit `we` flags (`-e`, `-d`, `-a`, `-E`, `-s`, `-t`) from left to right

This means explicit `we` inputs still override `.envrc` values.

To disable this behavior for a single invocation:

.. code-block:: bash

   $ we --no-direnv --env env.yml printenv

To disable via environment variable:

.. code-block:: bash

   $ WE_NO_DIRENV=1 we --env env.yml printenv

Take a look at the examples for more interesting uses for `we` that
